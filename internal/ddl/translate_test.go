package ddl

import (
	"strings"
	"testing"
)

func TestTranslatePostgresDDL_PreservesQuotedCase(t *testing.T) {
	ddl := `CREATE TABLE "CaseSchema"."CaseTable" ("MyCol" TEXT, unquoted INT)`
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), nil)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	stmt := stmts[0]
	if !strings.Contains(stmt, `"CaseSchema"."CaseTable"`) {
		t.Fatalf("expected quoted schema/table preserved: %s", stmt)
	}
	if !strings.Contains(stmt, `"MyCol"`) {
		t.Fatalf("expected quoted column preserved: %s", stmt)
	}
}

func TestTranslatePostgresDDL_UnquotedFolded(t *testing.T) {
	ddl := `CREATE TABLE FooBar (Bar INT)`
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), nil)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	stmt := stmts[0]
	if !strings.Contains(stmt, `"foobar"`) {
		t.Fatalf("expected unquoted table folded to lower-case: %s", stmt)
	}
	if !strings.Contains(stmt, `"bar"`) {
		t.Fatalf("expected unquoted column folded to lower-case: %s", stmt)
	}
}

func TestTranslatePostgresDDL_TypeMappings(t *testing.T) {
	ddl := `CREATE TABLE foo (id bigint, payload jsonb, tags text[], amount numeric(12,2))`
	mappings := map[string]string{
		"bigint":  "NUMBER",
		"jsonb":   "VARIANT",
		"text":    "STRING",
		"numeric": "NUMBER",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	stmt := stmts[0]
	if !strings.Contains(stmt, `"id" NUMBER`) {
		t.Fatalf("expected id mapped to NUMBER: %s", stmt)
	}
	if !strings.Contains(stmt, `"payload" VARIANT`) {
		t.Fatalf("expected payload mapped to VARIANT: %s", stmt)
	}
	if !strings.Contains(stmt, `"tags" ARRAY`) {
		t.Fatalf("expected tags mapped to ARRAY: %s", stmt)
	}
	if !strings.Contains(stmt, `"amount" NUMBER(12,2)`) {
		t.Fatalf("expected numeric suffix preserved: %s", stmt)
	}
}

func TestTranslatePostgresDDL_AlterColumnDefaultAndNullability(t *testing.T) {
	ddl := `ALTER TABLE public.widgets
		ALTER COLUMN name SET DEFAULT 'unknown',
		ALTER COLUMN name SET NOT NULL,
		ALTER COLUMN name DROP DEFAULT,
		ALTER COLUMN name DROP NOT NULL`

	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), nil)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	want := []string{
		`ALTER TABLE "public"."widgets" ALTER COLUMN "name" SET DEFAULT 'unknown'`,
		`ALTER TABLE "public"."widgets" ALTER COLUMN "name" SET NOT NULL`,
		`ALTER TABLE "public"."widgets" ALTER COLUMN "name" DROP DEFAULT`,
		`ALTER TABLE "public"."widgets" ALTER COLUMN "name" DROP NOT NULL`,
	}
	if len(stmts) != len(want) {
		t.Fatalf("expected %d statements, got %d (%v)", len(want), len(stmts), stmts)
	}
	for i := range want {
		if stmts[i] != want[i] {
			t.Fatalf("statement %d mismatch: got %q want %q", i, stmts[i], want[i])
		}
	}
}

func TestTranslatePostgresDDL_AlterColumnTypeUsingClause(t *testing.T) {
	ddl := `ALTER TABLE widgets ALTER COLUMN amount TYPE numeric(12,2) USING amount::numeric`
	mappings := map[string]string{
		"numeric": "NUMBER",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	if got := stmts[0]; got != `ALTER TABLE "widgets" ALTER COLUMN "amount" SET DATA TYPE NUMBER(12,2)` {
		t.Fatalf("unexpected statement: %s", got)
	}
}

func TestTranslatePostgresDDL_MultiActionAlterTableDuckDB(t *testing.T) {
	ddl := `ALTER TABLE public.widgets
		ADD COLUMN extra text,
		RENAME COLUMN extra TO details,
		DROP COLUMN details`
	mappings := map[string]string{
		"text": "TEXT",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectDuckDB), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	want := []string{
		`ALTER TABLE "public"."widgets" ADD COLUMN "extra" TEXT`,
		`ALTER TABLE "public"."widgets" RENAME COLUMN "extra" TO "details"`,
		`ALTER TABLE "public"."widgets" DROP COLUMN "details"`,
	}
	if len(stmts) != len(want) {
		t.Fatalf("expected %d statements, got %d (%v)", len(want), len(stmts), stmts)
	}
	for i := range want {
		if stmts[i] != want[i] {
			t.Fatalf("statement %d mismatch: got %q want %q", i, stmts[i], want[i])
		}
	}
}

func TestTranslatePostgresDDL_GeneratedColumnInCreateTable(t *testing.T) {
	ddl := `CREATE TABLE public.sales
		(order_id INT GENERATED BY DEFAULT AS IDENTITY,
			full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED,
			name text)`

	mappings := map[string]string{
		"int":  "INTEGER",
		"text": "STRING",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	stmt := stmts[0]
	want := `CREATE TABLE IF NOT EXISTS "public"."sales" ("order_id" INTEGER, "full_name" STRING, "name" STRING)`
	if stmt != want {
		t.Fatalf("unexpected statement: %s", stmt)
	}
}

func TestTranslatePostgresDDL_GeneratedColumnInAlterAddTable(t *testing.T) {
	ddl := `ALTER TABLE public.sales
		ADD COLUMN generated_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED,
		ADD COLUMN simple_id INT GENERATED BY DEFAULT AS IDENTITY`

	mappings := map[string]string{
		"text": "STRING",
		"int":  "INTEGER",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectDuckDB), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	want := []string{
		`ALTER TABLE "public"."sales" ADD COLUMN "generated_name" STRING`,
		`ALTER TABLE "public"."sales" ADD COLUMN "simple_id" INTEGER`,
	}
	if len(stmts) != len(want) {
		t.Fatalf("expected %d statements, got %d (%v)", len(want), len(stmts), stmts)
	}
	for i := range want {
		if stmts[i] != want[i] {
			t.Fatalf("statement %d mismatch: got %q want %q", i, stmts[i], want[i])
		}
	}
}

func TestTranslatePostgresDDL_RenameAndDropTableDuckDB(t *testing.T) {
	renameStmts, err := TranslatePostgresDDL(
		`RENAME TABLE public.widgets TO analytics.widgets_archive`,
		DialectConfigFor(DialectDuckDB),
		nil,
	)
	if err != nil {
		t.Fatalf("translate rename table: %v", err)
	}
	if len(renameStmts) != 1 {
		t.Fatalf("expected 1 rename statement, got %d", len(renameStmts))
	}
	if got := renameStmts[0]; got != `ALTER TABLE "public"."widgets" RENAME TO "analytics"."widgets_archive"` {
		t.Fatalf("unexpected rename statement: %s", got)
	}

	dropStmts, err := TranslatePostgresDDL(
		`DROP TABLE IF EXISTS public.widgets`,
		DialectConfigFor(DialectDuckDB),
		nil,
	)
	if err != nil {
		t.Fatalf("translate drop table: %v", err)
	}
	if len(dropStmts) != 1 {
		t.Fatalf("expected 1 drop statement, got %d", len(dropStmts))
	}
	if got := dropStmts[0]; got != `DROP TABLE IF EXISTS "public"."widgets"` {
		t.Fatalf("unexpected drop statement: %s", got)
	}
}

func TestTranslatePostgresDDL_ClickHouseRejectsAlterDefaults(t *testing.T) {
	_, err := TranslatePostgresDDL(
		`ALTER TABLE widgets ALTER COLUMN name SET DEFAULT 'x'`,
		DialectConfigFor(DialectClickHouse),
		nil,
	)
	if err == nil {
		t.Fatalf("expected error for clickhouse alter default")
	}
}
