package ddl

import (
	"encoding/json"
	"strings"
	"testing"

	schemadiff "github.com/josephjohncox/wallaby/internal/schema"
	"github.com/josephjohncox/wallaby/pkg/connector"
)

func TestTranslatePostgresDDL_PreservesQuotedCase(t *testing.T) {
	ddl := `CREATE TABLE "CaseSchema"."CaseTable" ("MyCol" TEXT, unquoted INT)`
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), nil)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	stmt := stmts[0]
	if !strings.Contains(stmt, `"CaseSchema"."CaseTable"`) {
		t.Fatalf("expected quoted schema/table preserved: %s", stmt)
	}
	if !strings.Contains(stmt, `"MyCol"`) {
		t.Fatalf("expected quoted column preserved: %s", stmt)
	}
}

func TestTranslatePostgresDDL_UnquotedFolded(t *testing.T) {
	ddl := `CREATE TABLE FooBar (Bar INT)`
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), nil)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	stmt := stmts[0]
	if !strings.Contains(stmt, `"foobar"`) {
		t.Fatalf("expected unquoted table folded to lower-case: %s", stmt)
	}
	if !strings.Contains(stmt, `"bar"`) {
		t.Fatalf("expected unquoted column folded to lower-case: %s", stmt)
	}
}

func TestTranslatePostgresDDL_TypeMappings(t *testing.T) {
	ddl := `CREATE TABLE foo (id bigint, payload jsonb, tags text[], amount numeric(12,2))`
	mappings := map[string]string{
		"bigint":  "NUMBER",
		"jsonb":   "VARIANT",
		"text":    "STRING",
		"numeric": "NUMBER",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	stmt := stmts[0]
	if !strings.Contains(stmt, `"id" NUMBER`) {
		t.Fatalf("expected id mapped to NUMBER: %s", stmt)
	}
	if !strings.Contains(stmt, `"payload" VARIANT`) {
		t.Fatalf("expected payload mapped to VARIANT: %s", stmt)
	}
	if !strings.Contains(stmt, `"tags" ARRAY`) {
		t.Fatalf("expected tags mapped to ARRAY: %s", stmt)
	}
	if !strings.Contains(stmt, `"amount" NUMBER(12,2)`) {
		t.Fatalf("expected numeric suffix preserved: %s", stmt)
	}
}

func TestTranslatePostgresDDL_AlterColumnDefaultAndNullability(t *testing.T) {
	ddl := `ALTER TABLE public.widgets
		ALTER COLUMN name SET DEFAULT 'unknown',
		ALTER COLUMN name SET NOT NULL,
		ALTER COLUMN name DROP DEFAULT,
		ALTER COLUMN name DROP NOT NULL`

	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), nil)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	want := []string{
		`ALTER TABLE "public"."widgets" ALTER COLUMN "name" SET DEFAULT 'unknown'`,
		`ALTER TABLE "public"."widgets" ALTER COLUMN "name" SET NOT NULL`,
		`ALTER TABLE "public"."widgets" ALTER COLUMN "name" DROP DEFAULT`,
		`ALTER TABLE "public"."widgets" ALTER COLUMN "name" DROP NOT NULL`,
	}
	if len(stmts) != len(want) {
		t.Fatalf("expected %d statements, got %d (%v)", len(want), len(stmts), stmts)
	}
	for i := range want {
		if stmts[i] != want[i] {
			t.Fatalf("statement %d mismatch: got %q want %q", i, stmts[i], want[i])
		}
	}
}

func TestTranslatePostgresDDL_AlterColumnTypeUsingClause(t *testing.T) {
	ddl := `ALTER TABLE widgets ALTER COLUMN amount TYPE numeric(12,2) USING amount::numeric`
	mappings := map[string]string{
		"numeric": "NUMBER",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	if got := stmts[0]; got != `ALTER TABLE "widgets" ALTER COLUMN "amount" SET DATA TYPE NUMBER(12,2)` {
		t.Fatalf("unexpected statement: %s", got)
	}
}

func TestTranslatePostgresDDL_MultiActionAlterTableDuckDB(t *testing.T) {
	ddl := `ALTER TABLE public.widgets
		ADD COLUMN extra text,
		RENAME COLUMN extra TO details,
		DROP COLUMN details`
	mappings := map[string]string{
		"text": "TEXT",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectDuckDB), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	want := []string{
		`ALTER TABLE "public"."widgets" ADD COLUMN "extra" TEXT`,
		`ALTER TABLE "public"."widgets" RENAME COLUMN "extra" TO "details"`,
		`ALTER TABLE "public"."widgets" DROP COLUMN "details"`,
	}
	if len(stmts) != len(want) {
		t.Fatalf("expected %d statements, got %d (%v)", len(want), len(stmts), stmts)
	}
	for i := range want {
		if stmts[i] != want[i] {
			t.Fatalf("statement %d mismatch: got %q want %q", i, stmts[i], want[i])
		}
	}
}

func TestTranslatePostgresDDL_GeneratedColumnInCreateTable(t *testing.T) {
	ddl := `CREATE TABLE public.sales
		(order_id INT GENERATED BY DEFAULT AS IDENTITY,
			full_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED,
			name text)`

	mappings := map[string]string{
		"int":  "INTEGER",
		"text": "STRING",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectSnowflake), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	if len(stmts) != 1 {
		t.Fatalf("expected 1 statement, got %d", len(stmts))
	}
	stmt := stmts[0]
	want := `CREATE TABLE IF NOT EXISTS "public"."sales" ("order_id" INTEGER, "full_name" STRING, "name" STRING)`
	if stmt != want {
		t.Fatalf("unexpected statement: %s", stmt)
	}
}

func TestTranslatePostgresDDL_GeneratedColumnInAlterAddTable(t *testing.T) {
	ddl := `ALTER TABLE public.sales
		ADD COLUMN generated_name TEXT GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED,
		ADD COLUMN simple_id INT GENERATED BY DEFAULT AS IDENTITY`

	mappings := map[string]string{
		"text": "STRING",
		"int":  "INTEGER",
	}
	stmts, err := TranslatePostgresDDL(ddl, DialectConfigFor(DialectDuckDB), mappings)
	if err != nil {
		t.Fatalf("translate ddl: %v", err)
	}
	want := []string{
		`ALTER TABLE "public"."sales" ADD COLUMN "generated_name" STRING`,
		`ALTER TABLE "public"."sales" ADD COLUMN "simple_id" INTEGER`,
	}
	if len(stmts) != len(want) {
		t.Fatalf("expected %d statements, got %d (%v)", len(want), len(stmts), stmts)
	}
	for i := range want {
		if stmts[i] != want[i] {
			t.Fatalf("statement %d mismatch: got %q want %q", i, stmts[i], want[i])
		}
	}
}

func TestTranslatePostgresDDL_RenameAndDropTableDuckDB(t *testing.T) {
	renameStmts, err := TranslatePostgresDDL(
		`RENAME TABLE public.widgets TO analytics.widgets_archive`,
		DialectConfigFor(DialectDuckDB),
		nil,
	)
	if err != nil {
		t.Fatalf("translate rename table: %v", err)
	}
	if len(renameStmts) != 1 {
		t.Fatalf("expected 1 rename statement, got %d", len(renameStmts))
	}
	if got := renameStmts[0]; got != `ALTER TABLE "public"."widgets" RENAME TO "analytics"."widgets_archive"` {
		t.Fatalf("unexpected rename statement: %s", got)
	}

	dropStmts, err := TranslatePostgresDDL(
		`DROP TABLE IF EXISTS public.widgets`,
		DialectConfigFor(DialectDuckDB),
		nil,
	)
	if err != nil {
		t.Fatalf("translate drop table: %v", err)
	}
	if len(dropStmts) != 1 {
		t.Fatalf("expected 1 drop statement, got %d", len(dropStmts))
	}
	if got := dropStmts[0]; got != `DROP TABLE IF EXISTS "public"."widgets"` {
		t.Fatalf("unexpected drop statement: %s", got)
	}
}

func TestTranslatePostgresDDL_ClickHouseRejectsAlterDefaults(t *testing.T) {
	_, err := TranslatePostgresDDL(
		`ALTER TABLE widgets ALTER COLUMN name SET DEFAULT 'x'`,
		DialectConfigFor(DialectClickHouse),
		nil,
	)
	if err == nil {
		t.Fatalf("expected error for clickhouse alter default")
	}
}

func TestTranslateRecordDDL_FromPlan(t *testing.T) {
	schemaDef := connector.Schema{
		Name:      "widgets",
		Namespace: "public",
		Columns: []connector.Column{
			{Name: "id", Type: "INTEGER"},
		},
	}
	plan := schemadiff.Plan{
		Changes: []schemadiff.Change{
			{Type: schemadiff.ChangeAddColumn, Namespace: "public", Table: "widgets", Column: "status", ToType: "text", Nullable: false},
			{Type: schemadiff.ChangeAlterColumn, Namespace: "public", Table: "widgets", Column: "id", FromType: "INTEGER", ToType: "bigint", FromNullable: false, Nullable: false},
			{Type: schemadiff.ChangeAlterColumn, Namespace: "public", Table: "widgets", Column: "status", FromType: "text", ToType: "text", FromNullable: true, Nullable: false},
			{Type: schemadiff.ChangeRenameColumn, Namespace: "public", Table: "widgets", Column: "created_at", ToColumn: "created_at_utc"},
		},
	}
	planBytes, err := json.Marshal(plan)
	if err != nil {
		t.Fatalf("marshal ddl plan: %v", err)
	}
	record := connector.Record{
		Operation: connector.OpDDL,
		Table:     "widgets",
		DDLPlan:   planBytes,
	}

	stmts, err := TranslateRecordDDL(schemaDef, record, DialectConfigFor(DialectDuckDB), nil, nil)
	if err != nil {
		t.Fatalf("translate record ddl: %v", err)
	}
	want := []string{
		`ALTER TABLE "public"."widgets" ADD COLUMN "status" text NOT NULL`,
		`ALTER TABLE "public"."widgets" ALTER COLUMN "id" SET DATA TYPE bigint`,
		`ALTER TABLE "public"."widgets" ALTER COLUMN "status" SET NOT NULL`,
		`ALTER TABLE "public"."widgets" RENAME COLUMN "created_at" TO "created_at_utc"`,
	}
	if len(stmts) != len(want) {
		t.Fatalf("expected %d statements, got %d (%v)", len(want), len(stmts), stmts)
	}
	for i := range want {
		if stmts[i] != want[i] {
			t.Fatalf("statement %d mismatch: got %q want %q", i, stmts[i], want[i])
		}
	}
}

func TestTranslateRecordDDL_RejectsGeneratedInPlan(t *testing.T) {
	schemaDef := connector.Schema{Name: "events"}
	plan := schemadiff.Plan{
		Changes: []schemadiff.Change{
			{Type: schemadiff.ChangeSetGenerated, Table: "events", Column: "value", Expression: "coalesce(value, 0)"},
		},
	}
	planBytes, err := json.Marshal(plan)
	if err != nil {
		t.Fatalf("marshal ddl plan: %v", err)
	}
	record := connector.Record{
		Operation: connector.OpDDL,
		DDLPlan:   planBytes,
	}
	if _, err := TranslateRecordDDL(schemaDef, record, DialectConfigFor(DialectDuckDB), nil, nil); err == nil {
		t.Fatalf("expected generated plan to be unsupported")
	}
}

func TestTranslateRecordDDL_RenameColumnUsesToColumnAndFallsBackToType(t *testing.T) {
	schemaDef := connector.Schema{
		Name:      "widgets",
		Namespace: "public",
	}
	plan := schemadiff.Plan{
		Changes: []schemadiff.Change{
			{Type: schemadiff.ChangeRenameColumn, Namespace: "public", Table: "widgets", Column: "created_at", ToType: "created_at_utc"},
		},
	}
	planBytes, err := json.Marshal(plan)
	if err != nil {
		t.Fatalf("marshal ddl plan: %v", err)
	}
	record := connector.Record{
		Operation: connector.OpDDL,
		DDLPlan:   planBytes,
	}

	stmts, err := TranslateRecordDDL(schemaDef, record, DialectConfigFor(DialectDuckDB), nil, nil)
	if err != nil {
		t.Fatalf("translate record ddl: %v", err)
	}
	if len(stmts) != 1 || stmts[0] != `ALTER TABLE "public"."widgets" RENAME COLUMN "created_at" TO "created_at_utc"` {
		t.Fatalf("unexpected rename stmts: %#v", stmts)
	}
}
